<?xml version="1.0" encoding="UTF-8" ?>
<schema name="muscatplus" version="1.6">
    <field name="_version_" type="long" indexed="true" docValues="false" stored="true" />
    <field name="_root_" type="string" indexed="true" stored="false" docValues="true" />
    <field name="_nest_path_" type="nest_path" />
    <field name="id" type="string" required="true" multiValued="false" />
    <field name="type" type="string" required="true" multiValued="false" />
    <field name="language" type="string" multiValued="false" />
    <field name="languages" type="string" multiValued="true" />
    <field name="text" type="text_fulltext" indexed="true" stored="true" termVectors="true" storeOffsetsWithPositions="true" />
    <field name="suggest" type="text_analyzed" indexed="true" stored="true" termVectors="true" multiValued="true" />
    <field name="boost" type="int" required="false" indexed="true" stored="true" />
    <field name="indexed" type="date" multiValued="false" indexed="true" />
    <field name="created" type="date" required="false" indexed="true" stored="true" />
    <field name="updated" type="date" required="false" indexed="true" stored="true" />

    <uniqueKey>id</uniqueKey>

    <dynamicField name="*_s" type="string" />
    <dynamicField name="*_sm" type="string" multiValued="true" />
    <dynamicField name="*_sni" type="ni_string" />
    <dynamicField name="*_smni" type="ni_string" multiValued="true" />
    <dynamicField name="*_id" type="string" />
    <dynamicField name="*_ids" type="string" multiValued="true" />
    <dynamicField name="*_uuid" type="uuid" />
    <dynamicField name="*_b" type="boolean" />
    <dynamicField name="*_i" type="int" />
    <dynamicField name="*_im" type="int" multiValued="true" />
    <dynamicField name="*_dt" type="date" />
    <dynamicField name="*_dtr" type="daterange" />
    <dynamicField name="*_loc" type="location" />
    <dynamicField name="*_lp" type="long" />
    <dynamicField name="*_ans" type="sort" stored="false" />

    <!-- Add a dynamic field that has fulltext query processing. useful for query-time boosting -->
    <dynamicField name="*_ft" type="text_fulltext" stored="false"/>
    <!-- Fulltext query processing, but not stored so can't be used for highlighting -->
    <dynamicField name="*_ftns" type="text_fulltext" stored="false" />
    <dynamicField name="*_kw" type="text_keyword" stored="false" />
    <dynamicField name="*_ti" type="text_instruments" stored="false" />
    <dynamicField name="*_wstok" type="text_whitespace_tokenized" stored="false" />
    <dynamicField name="*_al" type="text_analyzed" stored="false" />
    <dynamicField name="*_unp" type="text_unprocessed" stored="false" />
    <dynamicField name="*_sp" type="text_spell" stored="false" />
    <dynamicField name="*_json" type="json" multiValued="false" />

    <!-- Alphanumeric sort fields -->
    <copyField source="main_title_s" dest="main_title_ans" />
    <copyField source="name_s" dest="name_ans" />
    <copyField source="work_num_s" dest="work_num_ans" />

    <!-- copy to merged text fields. Copy here fields that are typically queried using words across fields,
    e.g., "beethoven symphony", which would come from the creator and the title fields. This is because Solr will
    use the qf field configuration below to essentially figure out which field to weight more heavily while
    performing a query, and NOT which fields to combine. So "beethoven symphony" with no text field will
    probably retrieve records where 'beethoven' and 'symphony' appeared in a single field (e.g., "A symphony dedicated
    to Beethoven" in the title field). -->
    <copyField source="main_title_s" dest="title_composer_ft" />
    <copyField source="source_title_s" dest="title_composer_ft" />
    <copyField source="creator_name_s" dest="title_composer_ft" />
    <copyField source="variant_title_s" dest="title_composer_ft" />
    <copyField source="standard_title_s" dest="title_composer_ft" />
    <copyField source="name_s" dest="title_composer_ft" />

    <!-- publication info -->
    <copyField source="publication_place_sm" dest="publication_info_ft" />
    <copyField source="publisher_copyist_sm" dest="publication_info_ft" />
    <copyField source="printer_name_sm" dest="publication_info_ft" />

    <!-- unified notes fields -->
    <copyField source="general_notes_sm" dest="notes_ft" />
    <copyField source="contents_notes_sm" dest="notes_ft" />
    <copyField source="performance_notes_sm" dest="notes_ft" />
    <copyField source="language_notes_sm" dest="notes_ft" />
    <copyField source="description_summary_sm" dest="notes_ft" />
    <copyField source="supplementary_material_sm" dest="notes_ft" />
    <copyField source="binding_notes_sm" dest="notes_ft" />
    <copyField source="source_of_description_notes_sm" dest="notes_ft" />
    <copyField source="watermark_notes_sm" dest="notes_ft" />

    <!-- identifiers fields. We put them in both types of fields
     since the 'analyzed' field can provide better results for literal
     searches. -->
    <!--    <copyField source="rism_id" dest="identifiers_ft" />-->
    <copyField source="rism_id" dest="identifiers_al" />
    <!--    <copyField source="shelfmark_s" dest="identifiers_ft" />-->
    <copyField source="shelfmark_s" dest="identifiers_al" />
    <!--    <copyField source="other_shelfmarks_sm" dest="identifiers_ft" />-->
    <copyField source="other_shelfmarks_sm" dest="identifiers_al" />
    <!--    <copyField source="former_shelfmarks_sm" dest="identifiers_ft" />-->
    <copyField source="former_shelfmarks_sm" dest="identifiers_al" />
    <!--    <copyField source="catalogue_numbers_sm" dest="identifiers_ft" />-->
    <copyField source="catalogue_numbers_sm" dest="identifiers_al" />
    <!--    <copyField source="plate_publisher_numbers_sm" dest="identifiers_ft" />-->
    <copyField source="plate_publisher_numbers_sm" dest="identifiers_al" />

    <!-- people fields -->
    <copyField source="name_s" dest="people_names_ft" />
    <copyField source="related_people_sm" dest="people_names_ft" />
    <copyField source="name_variants_sm" dest="people_names_ft" />

    <!-- institution fields -->
    <copyField source="institutions_sm" dest="institutions_ft" />

    <!-- subject fields -->
    <copyField source="subjects_sm" dest="subjects_ft" />
    <copyField source="term_s" dest="subjects_ft" />
    <copyField source="alternate_terms_sm" dest="subjects_ft" />

    <!-- location fields -->
    <copyField source="country_s" dest="location_ft" />
    <copyField source="city_s" dest="location_ft" />
    <copyField source="district_s" dest="location_ft" />

    <!-- fulltext fields -->
    <copyField source="roles_sm" dest="roles_ft" />

    <!-- fields that primarily hold sigla are indexed with the keyword field so that they are not split
        on boundaries, but are instead n-grammed to support wildcard lookups.
    -->
    <copyField source="siglum_s" dest="siglum_kw" />
    <copyField source="holding_institutions_sm" dest="holding_institutions_kw" />

    <!-- instrumentation fields are passed through a thesaurus to automatically expand and translate
         alternate terms (i.e., synonyms) of an instrument. -->
    <copyField source="scoring_summary_sm" dest="scoring_summary_ti" />

    <!-- rism id fields. These have minimal processing so that we can support direct RISM id lookup -->
    <copyField source="rism_id" dest="rism_id_wstok" />

    <!-- copy fingerprint data to other types of field for different sorts of analysis -->
    <copyField source="fingerprint_lp" dest="fingerprint_kw" />
    <copyField source="fingerprint_lp" dest="fingerprint_s" />

    <!-- field type definitions -->
    <fieldType name="nest_path" class="solr.NestPathField" />
    <fieldType name="uuid" class="solr.UUIDField" indexed="true" stored="true" docValues="true" />
    <fieldType name="string" class="solr.StrField" indexed="true" stored="true" sortMissingLast="true" docValues="true" termVectors="true" />
    <!-- use an Non-indexed string if you don't want the value of the string field to be indexed, e.g., a boilerplate rights statement that is on every record. -->
    <fieldType name="ni_string" class="solr.StrField" indexed="false" stored="true" sortMissingLast="true" />
    <fieldType name="boolean" class="solr.BoolField" indexed="true" stored="true" sortMissingLast="true" docValues="true" />
    <fieldType name="int" class="solr.IntPointField" docValues="true" sortMissingLast="true" />
    <fieldType name="location" class="solr.LatLonPointSpatialField" docValues="true" stored="true"/>
    <fieldType name="long" class="solr.LongPointField" docValues="true" sortMissingLast="true" />
    <fieldType name="date" class="solr.DatePointField" sortMissingLast="true" />
    <fieldType name="daterange" class="solr.DateRangeField" sortMissingLast="true" />
    <!-- sorting for alpha-numeric values. The 'strength=secondary' argument, as I'm sure your aware, is what controls case
         insensitive matching. -->
    <fieldType name="sort" class="solr.ICUCollationField" locale="" numeric="true" strength="secondary" sortMissingLast="true" />
    <!-- used for fields of long content (greater than the 'string' field capacity) but which do not need to be indexed -->
    <fieldType name="text_unprocessed" class="solr.TextField" indexed="false" stored="true" />
    <fieldType name="json" class="solr.TextField" indexed="false" stored="true" />


    <!-- text fields -->
    <fieldType name="text_fulltext" class="solr.TextField" autoGeneratePhraseQueries="true" multiValued="true" termVectors="true">
        <analyzer type="index">
            <tokenizer class="solr.ICUTokenizerFactory" />
            <filter class="solr.ICUFoldingFilterFactory"/>
            <filter class="solr.WordDelimiterGraphFilterFactory" splitOnNumerics="0" preserveOriginal="1" />
            <!--            <filter class="solr.KStemFilterFactory" />-->
            <!-- <filter class="solr.SynonymGraphFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true" /> -->
            <!-- <filter class="solr.CommonGramsFilterFactory" ignoreCase="true" words="stopwords.txt" /> -->
            <filter class="solr.FlattenGraphFilterFactory"/>
        </analyzer>
        <analyzer type="query">
            <tokenizer class="solr.ICUTokenizerFactory" />
            <filter class="solr.ICUFoldingFilterFactory"/>
            <filter class="solr.WordDelimiterGraphFilterFactory" splitOnNumerics="0" preserveOriginal="1" />
            <!--            <filter class="solr.KStemFilterFactory" />-->
            <!-- <filter class="solr.SynonymGraphFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true" /> -->
            <!--<filter class="solr.CommonGramsQueryFilterFactory" ignoreCase="true" words="stopwords.txt" /> -->
        </analyzer>
    </fieldType>

    <!-- a field that keeps hyphens and allows wildcard searches to support siglum search. Performs
     n-gram analysis to allow wildcard searching of any combination of tokens. -->
    <fieldType name="text_keyword" class="solr.TextField" multiValued="true">
        <analyzer type="index">
            <tokenizer class="solr.EdgeNGramTokenizerFactory" minGramSize="1" maxGramSize="6" />
        </analyzer>
    </fieldType>

    <!-- a field that passes query values through a synonym parser for instrument names. -->
    <fieldType name="text_instruments" class="solr.TextField" termVectors="true" multiValued="true">
        <analyzer type="query">
            <tokenizer class="solr.StandardTokenizerFactory"/>
            <filter class="solr.SynonymGraphFilterFactory" synonyms="instrument-synonyms.txt"
                    ignoreCase="true" expand="true"/>
        </analyzer>
    </fieldType>

    <fieldType name="text_whitespace_tokenized" class="solr.TextField" termVectors="true" multiValued="true">
        <analyzer type="index">
            <tokenizer class="solr.WhitespaceTokenizerFactory"/>
            <filter class="solr.WordDelimiterGraphFilterFactory"/>
            <filter class="solr.FlattenGraphFilterFactory"/> <!-- required on index analyzers after graph filters -->
        </analyzer>
        <analyzer type="query">
            <tokenizer class="solr.WhitespaceTokenizerFactory"/>
            <filter class="solr.WordDelimiterGraphFilterFactory"/>
        </analyzer>
    </fieldType>

    <!-- A differently-analyzed field to use for weighting full-text searches-->
    <fieldType name="text_analyzed" class="solr.TextField" multiValued="true" positionIncrementGap="100" termVectors="true">
        <analyzer type="index">
            <!-- the standard tokenizer removes any punctuation that is followed by whitespace,
                 e.g., "ms. bodl" to "ms bodl" -->
            <tokenizer class="solr.StandardTokenizerFactory" />
            <!-- the ICUFoldingFilter standardizes unicode characters,
                 e.g., "Dāstān" to "Dastan" -->
            <filter class="solr.ICUFoldingFilterFactory"/>
            <filter class="solr.LowerCaseFilterFactory" />
            <!-- shingles generate "word n-grams"; "the quick brown" to "the quick", "quick brown". -->
            <filter class="solr.ShingleFilterFactory" minShingleSize="2" maxShingleSize="5" />
        </analyzer>
        <analyzer type="query">
            <tokenizer class="solr.StandardTokenizerFactory" />
            <filter class="solr.ICUFoldingFilterFactory"/>
            <filter class="solr.LowerCaseFilterFactory" />
            <filter class="solr.ShingleFilterFactory" minShingleSize="2" maxShingleSize="5" />
        </analyzer>
    </fieldType>

    <fieldType name="text_spell" multiValued="true" class="solr.TextField" positionIncrementGap="100">
        <analyzer type="index">
            <tokenizer class="solr.ICUTokenizerFactory"/>
            <filter class="solr.LowerCaseFilterFactory"/>
            <filter class="solr.LengthFilterFactory" min="3" max="20" />
            <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
        </analyzer>
        <analyzer type="query">
            <tokenizer class="solr.ICUTokenizerFactory"/>
            <filter class="solr.LowerCaseFilterFactory"/>
            <filter class="solr.LengthFilterFactory" min="3" max="20" />
            <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
        </analyzer>
    </fieldType>

    <!-- German -->
    <dynamicField name="*_german" type="text_de"  indexed="true"  stored="true"/>
    <fieldType name="text_de" class="solr.TextField" positionIncrementGap="100">
        <analyzer>
            <tokenizer class="solr.StandardTokenizerFactory"/>
            <filter class="solr.LowerCaseFilterFactory"/>
            <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_de.txt" format="snowball" />
            <filter class="solr.GermanNormalizationFilterFactory"/>
            <filter class="solr.GermanLightStemFilterFactory"/>
            <!-- less aggressive: <filter class="solr.GermanMinimalStemFilterFactory"/> -->
            <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="German2"/> -->
        </analyzer>
    </fieldType>

    <!-- French -->
    <dynamicField name="*_french" type="text_fr"  indexed="true"  stored="true"/>
    <fieldType name="text_fr" class="solr.TextField" positionIncrementGap="100">
        <analyzer>
            <tokenizer class="solr.StandardTokenizerFactory"/>
            <!-- removes l', etc -->
            <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_fr.txt"/>
            <filter class="solr.LowerCaseFilterFactory"/>
            <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fr.txt" format="snowball" />
            <filter class="solr.FrenchLightStemFilterFactory"/>
            <!-- less aggressive: <filter class="solr.FrenchMinimalStemFilterFactory"/> -->
            <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="French"/> -->
        </analyzer>
    </fieldType>

    <!-- Italian -->
    <dynamicField name="*_italian" type="text_it"  indexed="true"  stored="true"/>
    <fieldType name="text_it" class="solr.TextField" positionIncrementGap="100">
        <analyzer>
            <tokenizer class="solr.StandardTokenizerFactory"/>
            <!-- removes l', etc -->
            <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_it.txt"/>
            <filter class="solr.LowerCaseFilterFactory"/>
            <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_it.txt" format="snowball" />
            <filter class="solr.ItalianLightStemFilterFactory"/>
            <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Italian"/> -->
        </analyzer>
    </fieldType>
</schema>
